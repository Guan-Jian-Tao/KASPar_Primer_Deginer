use strict;
use warnings;
use POSIX qw(tmpnam);
use Getopt::Long;
use File::Basename;
use File::Path qw(make_path);
use Cwd qw(abs_path);
use List::MoreUtils qw(uniq);
use Time::localtime;
use List::Util qw( min max );


## ======================================
## Usage: see -h
## ======================================

sub usage{
  warn <<END;
  Usage:
  Run by typing: perl KASP.PrimerDesign.Improved.pl -cfg [Parameter config file] -input [Flanking Seq fasta file] -out [Primer output] 
    Required params:
	-c|cfg							[s]	Parameter config file
	-i|input						[s]	Flanking Seq fasta file
	-o|out							[s]	Primer output
    Example: perl KASP.PrimerDesign.Improved.pl -cfg [Parameter config file] -input [Flanking Seq fasta file] -out [Primer output] 
END
  exit;
}
## ======================================
## Get options
## ======================================

my %opt;
%opt = (
	'help'				=> undef,
	'debug'				=> undef,
	'cfg'				=> undef,
	'input'				=> undef,
	'out'				=> undef
);

die usage() if @ARGV == 0;
GetOptions (
  'h|help'				=> \$opt{help},
  'debug'				=> \$opt{debug},
  'c|cfg=s'				=> \$opt{cfg},
  'i|input=s'			=> \$opt{input},
  'o|out=s'				=> \$opt{out}
) or die usage();

#check input paramaters
die usage() if $opt{help};
die usage() unless ( $opt{cfg} );
die usage() unless ( $opt{input} );
die usage() unless ( $opt{out} );

########
#Main Function
########
if (-e "Primer3.Log.txt"){
		system "rm Primer3.Log.txt";
}
if (-e "Blast.log.txt"){
		system "rm Blast.log.txt";
}
if (-e $opt{out}){
		system "rm $opt{out}";
}
my %params = &CFG_Parser($opt{cfg});
#print $params{'max_dist_for_sequencing'}."\n";
my %seq = &Seq_Parser($opt{input});
open(VCF,$opt{input});
my @vcf;
while(<VCF>){
	push @vcf,$_;
}
close VCF;

foreach my $snpid (sort keys %seq){
	print "                      \n";
	print "                      \n";
	print "########################################################\n";
	print "           Designing Primer for $snpid                  \n";
	print "########################################################\n";
	my @alleles = split /\//,$seq{$snpid}{"Alleles"};
	my $allele1 = $alleles[0];
	my $allele2 = $alleles[1];
	my @left_primers_set = &Get_Longest_Left_Primer_Seq($seq{$snpid}{"Left_Seq"});
	print "Left Primer has been generated! \n";
	my $fa = $left_primers_set[0];
	if (-e "Primer3.Left.tmp.fa"){
		system "rm Primer3.Left.tmp.fa";
	}
	open(FA,">Primer3.Left.tmp.fa");
	my $line = ">$fa\n$fa\n";
	print FA $line;
	close FA;
	my @left_primer_blast_out = &blast_run("Primer3.Left.tmp.fa","$snpid.Left.Primer.Blast.out");
	print "Blast for Left Primer is done!\n";
	#print "$seq{$snpid}{'Pos'}\n";
	
	my $right_seq = $seq{$snpid}{"Right_Seq"};
	&Right_Primer3_Input($snpid,$right_seq);
	(my $hright_primers_set, my $hPrimer_results) = &Primer3_Right_Run("Primer3.Right.tmp.input",$snpid);
	print "Right Primer has been generated by Primer3! \n";
	my @right_primers_set = @{$hright_primers_set};
	my %Primer_results = %{$hPrimer_results};
	my @fas = &Seq2Fa(@right_primers_set);
	if (-e "Primer3.Right.tmp.fa"){
		system "rm Primer3.Right.tmp.fa";
	}
	open(FA,">Primer3.Right.tmp.fa");
	foreach my $fa (@fas){
		print FA $fa;
	}
	close FA;
	my @Blast_out = &blast_run("Primer3.Right.tmp.fa","$snpid.Right.Primer.Blast.out");
	print "Blast for Right Primer is done!\n";
	(my $hpairs, my $huniqueness) = &determine_unique_primer_pairs(\@left_primer_blast_out,\@Blast_out,$seq{$snpid}{"Chr"},$seq{$snpid}{"Pos"});
	my @pairs = @{$hpairs};
	my @uniqueness = @{$huniqueness};
	
	open(OUT,">>$opt{out}");
	print OUT "##The KASP Primers of $snpid \n";
	print OUT "Forward_Primer\tReverse_Primer\tForward_Uniqueness\tReverse_Uniqueness\tForward_Start\tForward_End\tReverse_Start\tReverse_End\tProduct_Size\tPrimer3_Results\t0-based_start\tlen\t#N\tGC%\tTM\tself_any_th\tself_end_th\thairpin\tquality\n";
	if (@pairs){
		my $left = shift @pairs;
		my $check_adjacent = &adjacent_snp($left,@vcf);
		print "Checking adjacent SNPs ..... \n";
		if ($check_adjacent == 0) {
			print OUT "There is SNP falling in the Left Primer! \n";
			print "There is SNP falling in the Left Primer! \n";
			next;
		}
		my ($seq1, $sub_chr1, $a1, $b1, $c1, $d1, $e1, $f1, $pos11, $pos21, $score11, $score21, $g1, $h1) = split /\t/, $left;
		my $i = 0;
		foreach my $right (@pairs){
			#print "$right\n";
			my $check_adjacent = &adjacent_snp($right,@vcf);
			if ($check_adjacent == 0) {
				next;
			}
			my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $right;
			my $product_size = $pos1-$pos11;
			print OUT $seq1.$allele1."\t".$seq."\t".$uniqueness[0]."\t".$uniqueness[1]."\t".$pos11."\t".($pos21+1)."\t".$pos2."\t".$pos1."\t".$product_size."\t"."Priemer3_Results"."\t".$Primer_results{$seq}."\n";
			print OUT $seq1.$allele2."\t".$seq."\t".$uniqueness[0]."\t".$uniqueness[1]."\t".$pos11."\t".($pos21+1)."\t".$pos2."\t".$pos1."\t".$product_size."\t"."Priemer3_Results"."\t".$Primer_results{$seq}."\n";
			$i++;
		}
		print "Finally, $i Primer Pairs have been left! \nThe KASP Primers of $snpid have been successfully designed! The Primer sequences can be found in $opt{out}! \n";
		if ($i==0){
			print OUT "There is SNP falling in All Right Primers! \n";
			print "There is SNP falling in All Right Primers! \n";
		}
	} else {
		print OUT "Non Specific Primer can be found!\n";
		print "Non Specific Primer can be found!\n";
	}
	close OUT;
}


########
#Subfunction
########

sub CFG_Parser{
	my $cfgfile = shift;
	open(IN,$cfgfile);
	my %params;
	while(<IN>){
		chomp;s/\r//;
		next unless /\=/;
		my @g = split /\s*\=\s*/,$_;
		$params{$g[0]} = $g[1];
	}
	return %params;
}

sub Seq_Parser{
	my $fa = shift;
	my %seq;
	open(FA,$fa);
	while(<FA>){
		chomp;s/\r//;
		my @g = split /\t/,$_;
		my $snp_id = $g[0];
		my $chr = $g[1];
		my $pos = $g[2];
		my $seq = $g[3];
		my $left_seq; my $right_seq; my $allels;
		if ($seq =~ /(^\w+)\[/){
			$left_seq = $1;
		};
		if ($seq =~ /\](\w+$)/){
			$right_seq = $1;
		};
		if ($seq =~ /\[(.+)\]/){
			$allels = $1;
		};
		if ($left_seq && $right_seq && $snp_id && $pos && $chr){
			$seq{$snp_id}{"Left_Seq"} = $left_seq;
			$seq{$snp_id}{"Right_Seq"} = $right_seq;
			$seq{$snp_id}{"Alleles"} = $allels;
			$seq{$snp_id}{"Pos"} = $pos;
			$seq{$snp_id}{"Chr"} = $chr;
		}
	}
	close FA;
	return %seq;
}

sub Right_Primer3_Input {
	my $snpid = shift;
	my $right_seq = shift;
	die "The length of Right Flanking sequence is smaller than $params{'PRIMER_MIN_SIZE'}! " if (length($right_seq) < $params{"PRIMER_MIN_SIZE"});
	if (-e "Primer3.Right.tmp.input"){
		system "rm Primer3.Right.tmp.input";
	}
	my $tmp_input = "Primer3.Right.tmp.input";
	open (OUT,">$tmp_input");
	print OUT "SEQUENCE_ID"."=".$snpid."\n";
	print OUT "SEQUENCE_TEMPLATE"."=".$right_seq."\n";
	print OUT "SEQUENCE_TARGET"."="."0\,0"."\n";
	print OUT "PRIMER_TASK"."="."pick_right_only"."\n";
	print OUT "PRIMER_PICK_LEFT_PRIMER"."="."0"."\n";
	print OUT "PRIMER_PICK_INTERNAL_OLIGO"."="."0"."\n";
	print OUT "PRIMER_PICK_RIGHT_PRIMER"."="."1"."\n";
	print OUT "PRIMER_OPT_SIZE"."=".$params{"PRIMER_OPT_SIZE"}."\n";
	print OUT "PRIMER_MIN_SIZE"."=".$params{"PRIMER_MIN_SIZE"}."\n";
	print OUT "PRIMER_MAX_SIZE"."=".$params{"PRIMER_MAX_SIZE"}."\n";
	print OUT "PRIMER_MAX_TM"."=".$params{"PRIMER_MAX_TM"}."\n";
	print OUT "PRIMER_MIN_TM"."=".$params{"PRIMER_MIN_TM"}."\n";
	print OUT "PRIMER_OPT_TM"."=".$params{"PRIMER_OPT_TM"}."\n";
	print OUT "PRIMER_MAX_NS_ACCEPTED"."="."1"."\n";
	print OUT "PRIMER_PRODUCT_SIZE_RANGE"."=".$params{"min_pcr_product_size"}."-".$params{"max_pcr_product_size"}."\n";
	print OUT "P3_FILE_FLAG"."="."1"."\n";
	print OUT "SEQUENCE_INTERNAL_EXCLUDED_REGION"."="."0\,0"."\n";
	print OUT "PRIMER_EXPLAIN_FLAG"."="."1"."\n";
	print OUT "PRIMER_THERMODYNAMIC_PARAMETERS_PATH"."=".$params{"PRIMER_THERMODYNAMIC_PARAMETERS_PATH"}."\n";
	print OUT "=\n";
	close OUT;
	print "The Primer3 config file 'Primer3.Right.tmp.input' for Right Primer has been generated! \n";
}

sub Primer3_Right_Run {
	my $input = shift;
	my $snpid = shift;
	print "$input has been input into Primer3! \n";
	if (-e "$snpid.rev"){
		system "rm $snpid.rev";
	}
	system "$params{'primer3'} Primer3.Right.tmp.input > Primer3.Log.txt 2>&1 ";
	#print "$params{'primer3'} Primer3.Right.tmp.input > Primer3.Log.txt 2>&1 \n";
	print "primer3 is done! \n";
	my $reverse = "$snpid.rev";
	my $i=0;
	my @right_out;
	my %results;
	open(IN,$reverse);
	while(<IN>){
		chomp;s/\r//;
		$i++;
		if ($i==1){
			next;
		}
		next if /#/;
		$_ =~ s/\s+/\t/g;
		$_ =~ s/^\t//g;
		my @g = split /\t/,$_;
		#print "$g[1]\n";
		my $seq = $g[1];
		push @right_out,$seq;
		shift @g; shift @g;
		my $line = join "\t",@g;
		$results{$seq} = $line;
	}
	close IN;
	return (\@right_out, \%results);
}

sub blast_run {
	my $queryfile = shift;
	my $out = shift;
	if ($queryfile=~/Left/){
		print "Left Primer Sequences are being blasting! \n";
	} elsif ($queryfile=~/Right/){
		print "Right Primer Sequences are being blasting! \n";
	}
	#if (-e "tmp.blast.out"){
	#	system "rm tmp.blast.out";
	#}
	system "$params{'blastn'} -db $params{'reference_genome'} -query $queryfile -out $out -evalue $params{'evalue'} -num_threads $params{'num_cpus'} -outfmt \"6 std gaps nident\" -dust no -gapopen 4 -gapextend 2 -penalty -2 -reward 2 -word_size $params{'word_size'} -max_target_seqs 500 > Blast.log.txt 2>&1";
	#print "$params{'blastn'} -db $params{'reference_genome'} -query $queryfile -out $out -evalue $params{'evalue'} -num_threads $params{'num_cpus'} -outfmt \"6 std gaps nident\" -dust no -gapopen 4 -gapextend 2 -penalty -2 -reward 2 -word_size $params{'word_size'} -max_target_seqs 500 > Blast.log.txt 2>&1\n";
	my @out;
	open (OUT,"$out");
	while(<OUT>){
		chomp;s/\r//;
		push @out, $_;
	}
	close OUT;
	return @out;
}


sub Get_Longest_Left_Primer_Seq {
	my $left_seq = shift;
	print "Picking the Longest Left Primer! \n";
	die "The length of Left Flanking sequence is smaller than $params{'PRIMER_MIN_SIZE'}! " if (length($left_seq) < $params{"PRIMER_MIN_SIZE"});
	my @start_range;
	if ((length($left_seq) >= ($params{"PRIMER_MIN_SIZE"}-1) ) and (length($left_seq) <= ($params{"PRIMER_MAX_SIZE"}-1) )){
		@start_range = (0..($params{"len_flanking"} - $params{"PRIMER_MIN_SIZE"}+1+1-1));
	}elsif (length($left_seq) > ($params{"PRIMER_MAX_SIZE"}-1)){
		@start_range = (($params{"len_flanking"} - $params{"PRIMER_MAX_SIZE"}+1+1-1)..($params{"len_flanking"} - $params{"PRIMER_MIN_SIZE"}+1+1-1));
	}
	my $end = $params{"len_flanking"}-1;
	my @g = split //,$left_seq;
	my @left_primers_set;
	foreach my $start (@start_range){
		my @bases = @g[$start..$end];
		my $left_primer = join "",@bases;
		next if $left_primer =~ /N/;
		next if $left_primer =~ /n/;
		push @left_primers_set,$left_primer;
	}
	return @left_primers_set;
}



sub Seq2Fa {
	my @seqs = @_;
	my @fas;
	foreach my $seq (@seqs){
		my $fa = ">$seq\n$seq\n";
		push @fas, $fa;
	}
	return @fas;
}



sub Qualified_Blast_For_Primer {
	#"""Determine sequences with few enough mismatch and sequencable distance from blast output"""
	print "The Primer sequences is being filtering according to mismatch set! \n";
	my @blast_out= @_;
	my @Unique_Primer_Seq;
	foreach my $out (@blast_out){
		my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $out;
		my $len = length($seq);
		if (($h>$len-$params{"min_mismatches_close3p"}) or ($f<=$len-$params{"min_dist3p"} and $h>$len-$params{"min_mismatches"})){
				push @Unique_Primer_Seq, $out;
		}
	}
	return (@Unique_Primer_Seq);
}

sub determine_unique_primer_pairs {
	#"""Determine unique primer pairs from blast output"""
	(my $hleft_blast_out, my $hright_blast_out, my $query_chr, my $snp_pos) = @_;
	my @left_blast_out = @{$hleft_blast_out};
	my @right_blast_out = @{$hright_blast_out};
	my @unique_left_primer = &Qualified_Blast_For_Primer(@left_blast_out);
	print "The Left Primer has been filtered! \n";
	#print "@unique_left_primer \n";
	my @unique_right_primer = &Qualified_Blast_For_Primer(@right_blast_out);
	print "The Right Primer has been filtered! \n";
	my $numer_left_primer = scalar(@unique_left_primer);
	my $numer_right_primer = scalar(@unique_right_primer);
	my @pairs;my @uniqueness;
	##Left is unique and right is multiple
	if (($numer_left_primer==1) and ($numer_right_primer!=1)){
		foreach my $left (@unique_left_primer){
			my %right_candiates;
			foreach my $right (@right_blast_out){
				my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $right;
				my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
				my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
				if (($sub_chr eq $query_chr) and $max_dis < $params{"max_dist_for_sequencing"} and ($pos1 > $snp_pos)){
					push @{$right_candiates{$seq}},$right;
				}
			}
			push @pairs,$left;
			foreach my $seq (keys %right_candiates){
				if (scalar(@{$right_candiates{$seq}}) == 1){
					my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, ${$right_candiates{$seq}}[0];
					my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
					if (($max_dis <= $params{'max_pcr_product_size'}) and ($min_dis >= $params{'min_pcr_product_size'})){
						push @pairs,@{$right_candiates{$seq}};
					}
				}
			}
		}
		@uniqueness = ("Unique","NonUnique");
	} elsif (($numer_left_primer!=1) and ($numer_right_primer==1)){
		foreach my $right (@unique_right_primer){
			my @left_candiates;
			foreach my $left (@left_blast_out){
				my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $left;
				my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
				my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
				if (($sub_chr eq $query_chr) and ($max_dis < $params{"max_dist_for_sequencing"}) and ($pos1 < $snp_pos)){
					push @left_candiates,$left;
				}
			}
			if (scalar(@left_candiates) == 1){
				my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $left_candiates[0];
				my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
				if (($max_dis <= $params{'max_pcr_product_size'}) and ($min_dis >= 0) and (($pos2+1) == $snp_pos) ){
					push @pairs,@left_candiates;
					push @pairs,@unique_right_primer;
				}
			}
		}
		@uniqueness = ("NonUnique","Unique");
	} elsif ( ($numer_left_primer==1) and ($numer_right_primer==1) ){
		push @pairs,@unique_left_primer;
		push @pairs,@unique_right_primer;
		@uniqueness = ("Unique","Unique");
	} elsif ( ($numer_left_primer!=1) and ($numer_right_primer!=1)){
		my @left_candiates;
		my @other_chrs;
		my $index = 0;
		foreach my $left (@left_blast_out){
			my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $left;
			my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
			my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
			push @other_chrs, $sub_chr if ($sub_chr ne $query_chr);
			if (($sub_chr eq $query_chr) and ($max_dis < $params{"max_dist_for_sequencing"}) and ($pos1 < $snp_pos)){
				push @left_candiates,$left;
			} 
		}
		my %right_candiates;
		my %right_chrs;
		foreach my $right (@right_blast_out){
			my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $right;
			my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
			my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
			$right_chrs{$seq} .= "_".$sub_chr;
			if (($sub_chr eq $query_chr) and $max_dis < $params{"max_dist_for_sequencing"} and ($pos1 > $snp_pos) ){
				push @{$right_candiates{$seq}},$right;
			}
		}
		if ( scalar(@left_candiates) == 1 ){
			push @pairs, @left_candiates;
		} else {
			$index=1;
		}
		foreach my $seq (keys %right_candiates){
				next if $index==1;
				if ((scalar(@{$right_candiates{$seq}}) == 1) and (! &search($right_chrs{$seq},@other_chrs)) ){
					my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, ${$right_candiates{$seq}}[0];
					my $max_dis = max (abs($pos1-$snp_pos),abs($pos2-$snp_pos));my $min_dis = min (abs($pos1-$snp_pos),abs($pos2-$snp_pos));
					if (($max_dis <= $params{'max_pcr_product_size'}) and ($min_dis >= $params{'min_pcr_product_size'})){
						push @pairs,@{$right_candiates{$seq}};
					}
				}
		}
		@uniqueness = ("NonUnique","NonUnique");
	}
	if (scalar(@pairs) <= 1){@pairs = (),@uniqueness = ();};
	my $number = scalar(@pairs)-1;
	if ($number >=0 ){
		print "$number Unique Primers Pair has been determined! \n";
	} else {
		print "0 Unique Primers Pair has been determined! \n";
	}
	return (\@pairs,\@uniqueness);
}


sub search {
	(my $value, my @array) = @_;
	my $j=0;
	foreach my $v (@array){
		if ($value =~ /$v/){
			$j = 1;
		}
	}
	if ($j==1){
		return 1;
	} else {
		return 0;
	}
}


sub adjacent_snp {
	(my $blast_out, my @vcf) = @_;
	my ($seq, $sub_chr, $a, $b, $c, $d, $e, $f, $pos1, $pos2, $score1, $score2, $g, $h) = split /\t/, $blast_out;
	my $j = 0;
	foreach my $v (@vcf){
		next if $v =~ /^#/;
		chomp($v);$v=~s/\r//;
		my @g = split /\t/,$v;
		my $chr = $g[1];
		my $pos = $g[2];
		if ((($chr eq $sub_chr) and ($pos>=$pos1) and ($pos<=$pos2)) || ( ($chr eq $sub_chr) and ($pos>=$pos2) and ($pos<=$pos1) )){
			$j=1;
		}
	}
	if ($j==1){
		return 0;
	} else {
		return 1;
	}
}







